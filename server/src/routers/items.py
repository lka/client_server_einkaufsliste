"""Shopping list items endpoints.

This module provides endpoints for managing a shared shopping list.
All items are shared among all authenticated users - there is no per-user
ownership of items. Any authenticated user can:
- View all items in the shared list
- Add new items or update quantities of existing items
- Delete items from the shared list
- Convert items to products and assign departments
- Delete all items for a specific store

Items are automatically matched to products in the store catalog using
fuzzy matching, and similar item names are merged (e.g., "Möhre" merges with "Möhren").
"""

import uuid
from typing import List
from difflib import SequenceMatcher
from fastapi import APIRouter, HTTPException, Depends
from sqlmodel import select

from ..models import Item, Product, Department
from ..user_models import User
from ..db import get_session
from ..auth import get_current_user
from ..schemas import ItemWithDepartment, ConvertItemRequest
from ..utils import find_similar_item, merge_quantities, normalize_name

router = APIRouter(prefix="/api/items", tags=["items"])


@router.get("", response_model=List[ItemWithDepartment])
def read_items(current_user: str = Depends(get_current_user)):
    """Read all items from the shared shopping list (requires authentication).

    Returns all items from the shared shopping list with department information
    for grouping by department. This is a shared list - all authenticated users
    see the same items regardless of who added them.

    Args:
        current_user: Current authenticated username from JWT

    Returns:
        List[ItemWithDepartment]: All items from the shared list with department info.
    """
    with get_session() as session:
        # Get user to verify authentication
        user = session.exec(select(User).where(User.username == current_user)).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")

        # Get all items (shared list)
        items = session.exec(select(Item)).all()

        # Enrich items with department information
        items_with_dept = []
        for item in items:
            dept_id = None
            dept_name = None
            dept_sort_order = None

            # If item has a product, get department from product
            if item.product_id:
                product = session.get(Product, item.product_id)
                if product:
                    dept_id = product.department_id
                    department = session.get(Department, product.department_id)
                    if department:
                        dept_name = department.name
                        dept_sort_order = department.sort_order

            items_with_dept.append(
                ItemWithDepartment(
                    id=item.id,
                    user_id=item.user_id,
                    store_id=item.store_id,
                    product_id=item.product_id,
                    name=item.name,
                    menge=item.menge,
                    shopping_date=item.shopping_date,
                    department_id=dept_id,
                    department_name=dept_name,
                    department_sort_order=dept_sort_order,
                )
            )

        return items_with_dept


@router.post("", status_code=201, response_model=ItemWithDepartment)
def create_item(item: Item, current_user: str = Depends(get_current_user)):
    """Create a new item or update quantity if item already exists in the shared list.

    Adds items to the shared shopping list that all authenticated users can access.
    Uses fuzzy matching to find similar item names (e.g., "Möhre" matches "Möhren").
    Automatically matches items to products in the store's catalog using fuzzy matching.

    If an item with the same or similar name already exists in the shared list:
    - If the new unit matches an existing unit in the list, they are summed
    - If the new unit is different, it is appended to the comma-separated list

    Examples:
    - "Möhren 500 g" + "300 g" = "Möhren 800 g"
    - "Möhre 300 g" → merges with existing "Möhren" (fuzzy match)
    - "Zucker 500 g" + "2 Packungen" = "Zucker 500 g, 2 Packungen"
    - "Zucker 500 g, 2 Packungen" + "300 g" = "Zucker 800 g, 2 Packungen"
    - "Zucker 500 g, 2 Packungen" + "3 Packungen" = "Zucker 500 g, 5 Packungen"

    Note: Items are created with user_id=None as they belong to the shared list,
    not to individual users.

    Args:
        item (Item): Item payload to create. The id will be autogenerated
            if not provided. The user_id will be set to None.
        current_user: Current authenticated username from JWT

    Returns:
        ItemWithDepartment: The created or updated item with department information.
    """
    with get_session() as session:
        # Get user to verify authentication
        user = session.exec(select(User).where(User.username == current_user)).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")

        # First, check for exact match in shared list
        existing_item = session.exec(select(Item).where(Item.name == item.name)).first()

        # If no exact match, try fuzzy matching in shared list
        if not existing_item:
            existing_item = find_similar_item(session, item.name, None, threshold=0.8)

        result_item = None
        if existing_item:
            # Merge quantities into existing item
            existing_item.menge = merge_quantities(existing_item.menge, item.menge)
            session.add(existing_item)
            session.commit()
            session.refresh(existing_item)
            result_item = existing_item
        else:
            # Create new item
            if not item.id:
                item.id = str(uuid.uuid4())
            # Don't set user_id - this is a shared list
            item.user_id = None

            # If store_id is provided, try to find matching product
            if item.store_id and not item.product_id:
                # Get all products for this store
                products = session.exec(
                    select(Product).where(Product.store_id == item.store_id)
                ).all()

                if products:
                    # Fuzzy match against all products
                    normalized_query = normalize_name(item.name)
                    best_match = None
                    best_ratio = 0.0

                    for product in products:
                        normalized_product = normalize_name(product.name)
                        ratio = SequenceMatcher(
                            None, normalized_query, normalized_product
                        ).ratio()

                        if ratio > best_ratio:
                            best_ratio = ratio
                            best_match = product

                    # Assign product if match is good enough (threshold 0.6)
                    if best_ratio >= 0.6 and best_match:
                        item.product_id = best_match.id

            session.add(item)
            session.commit()
            session.refresh(item)
            result_item = item

        # Enrich with department information
        dept_id = None
        dept_name = None
        dept_sort_order = None

        if result_item.product_id:
            product = session.get(Product, result_item.product_id)
            if product:
                dept_id = product.department_id
                department = session.get(Department, product.department_id)
                if department:
                    dept_name = department.name
                    dept_sort_order = department.sort_order

        return ItemWithDepartment(
            id=result_item.id,
            user_id=result_item.user_id,
            store_id=result_item.store_id,
            product_id=result_item.product_id,
            name=result_item.name,
            menge=result_item.menge,
            shopping_date=result_item.shopping_date,
            department_id=dept_id,
            department_name=dept_name,
            department_sort_order=dept_sort_order,
        )


@router.delete("/{item_id}", status_code=204)
def delete_item(item_id: str, current_user: str = Depends(get_current_user)):
    """Delete an item by its id from the database (requires authentication).

    All authenticated users can delete items from the shared shopping list.

    Args:
        item_id (str): The id of the item to delete.
        current_user: Current authenticated username from JWT

    Raises:
        HTTPException: If the item does not exist (404).
    """
    with get_session() as session:
        # Verify user is authenticated
        user = session.exec(select(User).where(User.username == current_user)).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")

        item = session.get(Item, item_id)
        if not item:
            raise HTTPException(status_code=404, detail="Not found")
        session.delete(item)
        session.commit()
        return None


@router.post("/{item_id}/convert-to-product", response_model=ItemWithDepartment)
def convert_item_to_product(
    item_id: str,
    request: ConvertItemRequest,
    current_user: str = Depends(get_current_user),
):
    """Convert an item to a product and update the item's department assignment.

    Creates a new product based on the item name (without quantity),
    assigns it to the specified department, and updates the item to reference
    the new product.

    All authenticated users can convert items from the shared shopping list.

    Args:
        item_id: Item ID to convert
        request: Contains department_id to assign the product to
        current_user: Current authenticated username from JWT

    Returns:
        Updated item with department information
    """
    with get_session() as session:
        # Verify user is authenticated
        user = session.exec(select(User).where(User.username == current_user)).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")

        # Get item
        item = session.get(Item, item_id)
        if not item:
            raise HTTPException(status_code=404, detail="Item not found")

        # Get department and verify it exists
        department = session.get(Department, request.department_id)
        if not department:
            raise HTTPException(status_code=404, detail="Department not found")

        # Extract product name from item (remove quantity info)
        product_name = item.name.strip()

        # Check if product already exists with this name in this store
        existing_product = session.exec(
            select(Product).where(
                Product.name == product_name,
                Product.store_id == department.store_id,
            )
        ).first()

        if existing_product:
            # Use existing product
            product = existing_product
            # Update department if different
            if product.department_id != request.department_id:
                product.department_id = request.department_id
                session.add(product)
        else:
            # Create new product
            product = Product(
                name=product_name,
                store_id=department.store_id,
                department_id=request.department_id,
                fresh=False,
            )
            session.add(product)
            session.flush()  # Get product ID

        # Update item with product reference
        item.product_id = product.id
        session.add(item)
        session.commit()
        session.refresh(item)

        # Return item with department info
        dept = session.get(Department, request.department_id)
        return ItemWithDepartment(
            id=str(item.id),
            user_id=item.user_id,
            name=item.name,
            menge=item.menge,
            shopping_date=item.shopping_date,
            store_id=item.store_id,
            product_id=item.product_id,
            department_id=dept.id if dept else None,
            department_name=dept.name if dept else None,
            department_sort_order=dept.sort_order if dept else None,
        )


# Store-specific item endpoints
stores_items_router = APIRouter(prefix="/api/stores", tags=["items"])


@stores_items_router.delete("/{store_id}/items", status_code=204)
def delete_store_items(store_id: int, current_user: str = Depends(get_current_user)):
    """Delete all items for a specific store (requires authentication).

    Deletes all items from the shared shopping list for the specified store.
    All authenticated users can delete items from the shared list.

    Args:
        store_id: Store ID to delete items for
        current_user: Current authenticated username from JWT

    Returns:
        None (204 No Content)
    """
    with get_session() as session:
        # Verify user is authenticated
        user = session.exec(select(User).where(User.username == current_user)).first()
        if not user:
            raise HTTPException(status_code=404, detail="User not found")

        # Delete all items for this store (from shared list)
        items = session.exec(select(Item).where(Item.store_id == store_id)).all()

        for item in items:
            session.delete(item)

        session.commit()
        return None
